{-------------------------------------------------------------------------------

        Copyright:              The Hatchet Team (see file Contributors)

        Module:                 TypeUtils

        Description:            Utility functions for manipulating types,
                                and converting between the syntactic
                                representation of types and the internal
                                representation of types.

        Primary Authors:        Bernie Pope

        Notes:                  See the file License for license information

-------------------------------------------------------------------------------}

module TypeUtils (aHsTypeToType,
                  aHsTypeSigToAssumps,
                  aHsAsstToPred,
                  flattenLeftTypeApplication) where

import HsSyn    
import Representation      

import Type                     (tv, 
                                 quantify, 
                                 makeAssump,
                                 assumpScheme,
                                 tTTuple,
                                 assumpId)

import Utils   (fromHsName)
import KindInfer                (KindEnv, 
                            --     kiHsQualType,
                                hsQualTypeToScheme,
                                 kindOf)
import Atom
import Control.Monad.Identity

-------------------------------------------------------------------------------------------
--
--  The conversion functions:
--
--    aHsTypeToType

--------------------------------------------------------------------------------
    
-- note that the types are generated without generalised type
-- variables, ie there will be no TGens in the output
-- to get the generalised variables a second phase
-- of generalisation must be applied

aHsTypeToType :: KindEnv -> HsType -> Type

-- arrows

aHsTypeToType kt (HsTyFun t1 t2)
   = aHsTypeToType kt t1 `fn` aHsTypeToType kt t2

-- tuples

aHsTypeToType kt tuple@(HsTyTuple types)
   = tTTuple $ map (aHsTypeToType kt) types

-- application

aHsTypeToType kt (HsTyApp t1 t2)
   = TAp (aHsTypeToType kt t1) (aHsTypeToType kt t2)

-- variables, we must know the kind of the variable here!
-- they are assumed to already exist in the kindInfoTable
-- which was generated by the process of KindInference

aHsTypeToType kt (HsTyVar name)
   = TVar $ tyvar  name (kindOf name kt)

-- type constructors, we must know the kind of the constructor.
-- here we also qualify the type constructor if it is 
-- currently unqualified

aHsTypeToType kt (HsTyCon name)
   = TCon $ Tycon name (kindOf name kt)

aHsQualTypeToQualType :: KindEnv -> HsQualType -> Qual Type
aHsQualTypeToQualType kt (HsQualType cntxt t)
   = map (aHsAsstToPred kt) cntxt :=> aHsTypeToType kt t
aHsQualTypeToQualType kt (HsUnQualType t)
   = [] :=> aHsTypeToType kt t

-- this version quantifies all the type variables
-- perhaps there should be a version that is 
-- parameterised with which variables to quantify

aHsQualTypeToScheme :: KindEnv -> HsQualType -> Scheme
aHsQualTypeToScheme kt qualType
   = quantify vars qt
   where
   qt = aHsQualTypeToQualType kt qualType
   vars = tv qt 

-- one sig can be given to multiple names, hence
-- the multiple assumptions in the output

{-
aHsTypeSigToAssumps :: KindEnv -> HsDecl -> [Assump]
aHsTypeSigToAssumps kt sig@(HsTypeSig _ names qualType)
   = [n :>: scheme | n <- names]
   where
   scheme = aHsQualTypeToScheme newEnv qualType 
   --newEnv = kiHsQualType kt qualType 
   newEnv = kt
-}



aHsAsstToPred :: KindEnv -> HsAsst -> Pred
aHsAsstToPred kt (className, varName)
   -- = IsIn className (TVar $ Tyvar varName (kindOf varName kt)) 
   = IsIn className (TVar $ tyvar varName (kindOf className kt)) 

-- one sig can be given to multiple names, hence
-- the multiple assumptions in the output

aHsTypeSigToAssumps :: KindEnv -> HsDecl -> [Assump]
aHsTypeSigToAssumps kt sig@(HsTypeSig _ names qualType) = [n :>: scheme | n <- names] where
    Identity scheme = hsQualTypeToScheme kt qualType
   --scheme = aHsQualTypeToScheme newEnv qualType 
   --newEnv = kiHsQualType kt qualType 

{-
   converts leftmost type applications into lists

   (((TC v1) v2) v3) => [TC, v1, v2, v3]

-}
flattenLeftTypeApplication :: HsType -> [HsType]
flattenLeftTypeApplication t
   = flatTypeAcc t []
   where
   flatTypeAcc (HsTyApp t1 t2) acc
      = flatTypeAcc t1 (t2:acc)
   flatTypeAcc nonTypApp acc
      = nonTypApp:acc

-- qualifies a type assumption to a given module, unless
-- it is already qualified

qualifyAssump :: Module -> Assump -> Assump 
qualifyAssump mod assump
   | isQual ident = assump  -- do nothing 
   | otherwise = makeAssump newQualIdent scheme
   where
   scheme :: Scheme
   scheme = assumpScheme assump
   ident :: HsName
   ident = assumpId assump 
   newQualIdent :: HsName
   newQualIdent = Qual mod $ HsIdent $ fromHsName ident
